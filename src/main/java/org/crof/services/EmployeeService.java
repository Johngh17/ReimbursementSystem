package org.crof.services;

import org.apache.log4j.LogManager;
import org.apache.log4j.Logger;
import org.crof.models.Employee;
import org.crof.repositories.EmployeeDAO;

import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

public class EmployeeService {
    EmployeeDAO employeeDAO;
    private Logger logger = LogManager.getLogger(EmployeeService.class.getName());

    public EmployeeService(EmployeeDAO employeeDAO){
        this.employeeDAO = employeeDAO;
    }

    /**
     * Checks whether the given password corresponds to the given password
     * @param username the username that someone is trying to log in as
     * @param password the password that was given
     * @return whether the username/password combo is valid
     */
    public boolean validateLogin(String username, String password){
        boolean validCombo = false;
        if(employeeDAO.getEmployeesByUsername().containsKey(username)){
            Employee current = employeeDAO.getEmployeesByUsername().get(username);
            validCombo = current.getPassword().equals(password);
        }
        return validCombo;
    }

    /**
     * Creates an employee and adds them to the database
     * @param firstname the first name of the employee
     * @param lastname the last name of the employee
     * @param username the username of the employee
     * @param password the password of the employee
     * @return the employee ID of the employee generated by being saved in the database
     */
    public int createEmployee(String firstname, String lastname, String username, String password){
        if(usernameAvailable(username)) {
            Employee employee = new Employee();
            employee.setFirstname(firstname);
            employee.setLastname(lastname);
            employee.setUsername(username);
            employee.setPassword(password);
            return employeeDAO.save(employee);
        }
        return -1;
    }

    /**
     * Updates the information of a specified employee under the authority of either that employee or an admin
     * @param authority the authorizing employee, should be the user themselves or an admin
     * @param username the employee who is having their information updated
     * @param firstname the new first name of the employee
     * @param lastname the new last name of the employee
     * @return "Updated" if the user had the authority to update the user's information and there were no errors
     */
    public String updateInfo(String authority, String username, String firstname, String lastname){
        String updated = "You do not have the permission to change this information";
        boolean authIsAdmin = employeeDAO.getEmployeesByUsername().containsKey(authority) && employeeDAO.getEmployeesByUsername().get(authority).isAdmin();
        if(authIsAdmin || authority.equals(username)) {
            Employee employee = employeeDAO.getEmployeesByUsername().get(username);
            logger.info("Setting name to " + firstname + " " + lastname);
            employee.setFirstname(firstname);
            employee.setLastname(lastname);
            employeeDAO.save(employee);
            updated = "Updated";
        }
        return updated;
    }

    public String updatePassword(String username, String password){
        Employee employee = employeeDAO.getEmployeesByUsername().get(username);
        employee.setPassword(password);
        return "" + employeeDAO.save(employee);
    }

    /**
     * Checks whether a username exists in the cached data. This only works if we can assume that users are not being
     * added elsewhere after the server starts.
     * @param username
     * @return
     */
    public boolean usernameAvailable(String username){
        return !employeeDAO.getEmployeesByUsername().containsKey(username);
    }

    /**
     * Gets all of the employees as a map from their IDs to their selves
     * @return
     */
    public Map<Integer,Employee> getAllEmployees(){
        return employeeDAO.getEmployees();
    }

    /**
     * Get an employee by their username
     * @param username the employee's username
     * @return the employee with the given username
     */
    public Employee getEmployee(String username){
        Employee current;
        if(employeeDAO.getEmployeesByUsername().containsKey(username)){
            current = employeeDAO.getEmployeesByUsername().get(username);
        }
        else{
            current = employeeDAO.load(username);
        }
        return current;
    }

    /**
     * Gets the next administrator from the queue based on how busy they have been. This is currently measured purely
     * in terms of how many reimbursement requests they have ever received.
     * @return
     */
    public Employee getNextAdmin(){
        List<Employee> admins = employeeDAO.getAdmins();
        Employee tasked = admins.get(0);
        for(Employee admin: admins){
            if(tasked.getReviewableRequests().size() > admin.getReviewableRequests().size()){
                tasked = admin;
            }
        }
        return tasked;
    }

    public void deleteEmployee(Employee employee){
        employeeDAO.deleteEmployee(employee);
    }

    /**
     * Gets all of the employees as a set
     * @return
     */
    public Set<Employee> getEmployeeSet(){
        Set<Employee> employees = new HashSet<>();
        for(Employee employee: employeeDAO.getEmployees().values()){
            employees.add(employee);
        }
        return employees;
    }

}
